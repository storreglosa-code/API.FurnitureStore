GENERATE TOKEN (Video 36) Se van a utilizar varias clases/métodos/propiedades propias de la librería JWT para facilitar su implementación.
El token JWT termina siendo un string, sólo que esta encriptado. 

 private string GenerateToken(IdentityUser user) ----> Método privado ya que se va a utilizar únicamente por esta clase
 {
     var jwtTokenHandler = new JwtSecurityTokenHandler(); ----> Crea el token propiamente dicho
     var key = Encoding.UTF8.GetBytes(_jwtConfig.Secret); ----> Esto es lo que hicimos en Program.cs --> Cuando agregamos el servicio de autenticación [AddJwtBearer --> Encoding.ASCII bla bla]

     var tokenDescriptor = new SecurityTokenDescriptor() ----> Es en donde voy a agregar todas las propiedades/información que va a contener el token.
     {
         Subject = new ClaimsIdentity(new ClaimsIdentity(new[] ----> Agregamos toda la información del usuario (CLAIMS) 
         {	
             new Claim("Id", user.Id),										----> JwtRegisteredClaimNames ---->Este ENUM contiene los distintos Claims registrados por defecto.
             new Claim(Microsoft.IdentityModel.JsonWebTokens.JwtRegisteredClaimNames.Sub, user.Email), 		----> SUB va a ser el nombre del usuario/Emaildefecto.
             new Claim(Microsoft.IdentityModel.JsonWebTokens.JwtRegisteredClaimNames.Email, user.Email),	
             new Claim(Microsoft.IdentityModel.JsonWebTokens.JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()), ----> Clasico Claim opcional. Hace referencia a JWT Id. Es un claim que se utiliza para prevenir ataques de volver a utilizar el token. Es el ID del Token en sí.
             new Claim(Microsoft.IdentityModel.JsonWebTokens.JwtRegisteredClaimNames.Iat, DateTime.Now.ToUniversalTime().ToString()) ----> IAT (Issued At) Identifica datetime a la cual el token fue emitido.
         })),
         Expires = DateTime.Now.AddDays(1),		----> Expira en un dia. 
         SigningCredentials = new SigningCredentials (new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256) ----> En Program.cs vimos que se va a usar SymmetricSecurityKey para asegurar la firma del emisor y también se tiene que validar.
     };

     var token = jwtTokenHandler.CreateToken(tokenDescriptor); --> "Tokeniza" toda la descripción generada anteriormente.--> Devuelve un SECURITY TOKEN

     return jwtTokenHandler.WriteToken(token); ---> Transforma el token en un string, que es en definitiva lo que queríamos.
 }


GENERAR EL TOKEN EN SI, ES GENERAR UN STRING CON INFORMACION PUNTUAL DE MANERA ENCRIPTADA.
